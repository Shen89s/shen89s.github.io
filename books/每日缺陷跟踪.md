# 每日缺陷跟踪

“缺陷”是测试的结果，对于所有的测试人员，每天跟踪缺陷非常重要，因为对于测试人员来说需要实时关注测试中的这介个问题。

口  哪些缺陷在本版本中必须解决？

口  哪些缺陷在本版本中需要解决？

口  缺陷的趋势是否正常？

口  是否存在修改缺陷而引入了新缺陷？

![](https://shen89s.github.io/resFiles/每日缺陷跟踪需要关注的问题.jpg)

这几个问题都会影响后续测试的执行，测试架构师在必要的时刻可能也需要由此来调整测试策略。

## 1.哪些缺陷必须在本版本中解决

在版本测试过程中，判定该问题的标准只有一个，那就是“会不会对后续测试造成阻塞”。   
需要注意的是不要和“缺陷的严重级别”混淆。缺陷的严重级别是指缺陷如果不修复，会对用户造成的影响。我们通常认为缺陷的严重程度越高，修复它的优先级就应该越高，这一点没问题，但是严重或致命的缺陷，却不一定会让测试用例执行发生“阻塞”。   

例如，我们在做ABC系统模块的集成功能测试，如图我们会有4条测试用例，假设我们已知B模块存在bug1和bug2，那么执行测试用例时，所有经过bug所在方块的用例执行结果都会是失败，如图所示用例1、用例3、用例4的执行结果都会失败。用例1的测试没有执行到代码C中，用例3的测试没有执行到代码A中，这时我们可以称用例1和用例3被bug1阻塞了，和测试用例4执行结果为失败不同的是，用例1和用3执行存在阻塞，这种阻塞体现了一种未知性：我们并不知道这些用例最后的执行结果是什么，意味着测试内容并没有顺利的执行完。   

我们在来分析一下bug1和bug2，假设对于用户来说，bug1的严重程度是一般，bug2的严重程度为严重，此时资源只允许我们修复1个缺陷，我们应该优先修复那个缺陷呢？我们应该优先修复bug1，这是因为bug2只有到了产品发布阶段才会造成严重的用户影响，而bug1如果不修复，那么下个版本用例1和用例3还是不能执行，对于测试来说本版本测试内容依然还没完成。   
![](https://shen89s.github.io/resFiles/r2/缺陷优先级.jpg)

需要我们测试人员铭记的是，修复对测试有阻塞的缺陷优先级应该更高，比修复普通严重缺陷以及开发新功能相比。“测试阻塞”意味着测试并没有完成本版本的功能的严重，被阻塞的部分功能质量是未知的。如果放任不管而继续开发新功能，会大大增加集成时的风险。因此我们通常在提缺陷的时候除了标注严重级别意外，还有标注优先级，严重级别一旦达成一致以后不再改变，而优先级通常会随着缺陷的修复情况随时调整，以指导开发人员修复缺陷的顺序。

## 2.哪些缺陷在本版本中需要解决

是指我们希望在本版本中修复的缺陷。显然本版本中需要解决的缺陷，包含上一小节我们讨论的“本版本中必须解决的缺陷”。换句话说，除了那些在本版本中必须解决的缺陷，我们还需要根据缺陷的严重级别和缺陷的修复情况再选择一些缺陷，在本版本中优先解决。作为测试人员除了不亲自上手修复缺陷以外，应该尽可能的指导开发人员加快缺陷的修复进度，其中指导开发进行正确的修复顺序就是一项很重要的工作。   

本版本中需要优先解决的缺陷因素：   

口  缺陷修复改动越大，越需要尽早修复。

口  涉及需求、方案、设计的修改，需要尽早修复。

口  缺陷严重级别为“致命”和“严重”的缺陷，需要尽早修复。   

例如，我们在某一个build版本中一共发现15个缺陷，情况如下表：
<table>
	<tr>
		<th>缺陷</th>
		<th>是否会测试阻塞</th>
		<th>缺陷严重级别</th>
		<th>缺陷修复改动</th>
	</tr>
	<tr>
		<td>缺陷1</td>
		<td>是</td>
		<td>一般</td>
		<td>改动一般</td>
	</tr>
	<tr>
		<td>缺陷2</td>
		<td>否</td>
		<td>致命</td>
		<td>改动一般</td>
	</tr>
	<tr>
		<td>缺陷3</td>
		<td>是</td>
		<td>一般</td>
		<td>改动一般</td>
	</tr> 
	<tr>
		<td>缺陷4</td>
		<td>是</td>
		<td>严重</td>
		<td>改动复杂</td>
	</tr>
	<tr>
		<td>缺陷5</td>
		<td>否</td>
		<td>致命</td>
		<td>改动一般</td>
	</tr> 	
	<tr>
		<td>缺陷6</td>
		<td>否</td>
		<td>致命</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷7</td>
		<td>否</td>
		<td>严重</td>
		<td>改动一般</td>
	</tr> 	
	<tr>
		<td>缺陷8</td>
		<td>否</td>
		<td>严重</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷9</td>
		<td>否</td>
		<td>严重</td>
		<td>涉及需求</td>
	</tr> 	
	<tr>
		<td>缺陷10</td>
		<td>否</td>
		<td>一般</td>
		<td>改动一般</td>
	</tr> 	
	<tr>
		<td>缺陷11</td>
		<td>否</td>
		<td>一般</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷12</td>
		<td>否</td>
		<td>一般</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷13</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 
	<tr>
		<td>缺陷14</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 
	<tr>
		<td>缺陷15</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 
</table>

我们假设在本版本中，开发人员有能力修复8个缺陷，那么其中缺陷1、缺陷3、缺陷4会造成测试阻塞，为必须解决。剩下的缺陷，我们根据缺陷的严重级别、改动大小情况来排序，分析选取过程我们可以按照如下方式选取：   

口  对测试阻塞必须解决的缺陷-缺陷1、缺陷3、缺陷4

口  缺陷严重级别非常高，缺陷改动大(复杂/涉及需求)-缺陷6

口  缺陷严重级别非常高，缺陷改动一般-缺陷2、缺陷5

口  缺陷严重级别高，缺陷改动大(复杂/涉及需求)-缺陷8、缺陷9

口  缺陷严重级别高，缺陷改动一般-缺陷7

口  缺陷严重级一般，缺陷改动大(复杂/涉及需求)-缺陷11、缺陷12

口  缺陷严重级一般，缺陷改动一般-缺陷10

口  其他-缺陷13、缺陷14、缺陷15

按照排序我们选择了缺陷2、缺陷5、缺陷6、缺陷8、缺陷9，最后我们本版本需要解决的缺陷是：缺陷1、缺陷2、缺陷3、缺陷4、缺陷5、缺陷6、缺陷8、缺陷9。
需要注意的时，即使都是本版本中需要解决的缺陷，也需要注意优先级：缺陷1、缺陷3、缺陷4、缺陷6、缺陷2、缺陷5、缺陷8、缺陷9。

## 3.缺陷趋势是否正常

[缺陷趋势分析技术](books/缺陷趋势分析.md)能够帮助我们分析缺陷是否收敛，在测试过程中我们通过关注分析累积发现的缺陷趋势图，就可以判断缺陷趋势是否正常。


