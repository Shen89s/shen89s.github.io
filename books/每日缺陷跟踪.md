# 每日缺陷跟踪

对于我们测试人员来说，“缺陷”是我们测试工作的重要成果物之一，正如缺陷分析技术章节所说的，如果我们仅仅将缺陷进行记录而不去分析就是在太可惜了。
今天我们就来说说，缺陷分析常规手段或者常规操作之一“每日缺陷跟踪”。每日缺陷跟踪见名知意，就是每天关注和跟踪发现的缺陷情况。通常我们在跟踪缺陷时需要重点关注这几个问题：   
口  哪些缺陷在本版本中必须解决？   
口  哪些缺陷在本版本中需要解决？   
口  当前缺陷趋势是否正常？   
口  当前缺陷修复是否引入了新缺陷？

![](https://shen89s.github.io/resFiles/r2/每日缺陷跟踪.jpg)

这几个问题都会影响后续测试的执行，测试人员需要实时关注，在必要的时刻需要由此来调整测试策略。

## 1.哪些缺陷必须在本版本中解决

在测试过程中，判定该问题的标准只有一个，那就是“会不会对后续测试造成阻塞”，需要注意不要和[“缺陷的严重级别”](books/缺陷密度分析.md)混淆。缺陷的严重级别是指缺陷如果不修复，会对用户造成的影响。我们通常认为缺陷的严重程度越高，修复它的优先级就应该越高，这一点没问题，但是严重或致命的缺陷，却不一定会让测试用例执行发生“阻塞”。   

举个例子，假如我们在做一个系统的ABC三个模块的功能集成测试，如图我们会有4条测试用例，假设我们已知B模块存在bug1和bug2，那么在执行测试用例时，所有经过bug所在方块的用例执行结果都会是失败，如图所示用例1、用例3、用例4的执行结果都会失败。用例1的测试没有执行到代码C中，用例3的测试没有执行到代码A中，这时我们可以称用例1和用例3被bug1阻塞了，和测试用例4执行结果为失败是不同的，用例1和用3执行存在阻塞，这种阻塞体现了一种未知性：我们并不知道这些用例最后的执行结果是什么，意味着测试内容并没有顺利的执行完。   

我们在来分析一下bug1和bug2，假设对于用户来说，bug1的严重程度是一般，bug2的严重程度为严重，此时资源只允许我们修复1个缺陷，我们应该优先修复那个缺陷呢？我们应该优先修复bug1，这是因为bug2只有到了产品发布阶段才会造成严重的用户影响，而bug1如果不修复，那么下个版本用例1和用例3还是不能执行，对于测试来说本版本测试内容依然还没完成，影响了测试工作的继续，一个优秀团队里的成员，不会只顾自己的工作，而把未知和压力抛到后期或队友，正确的协作才是一个团队的灵魂。

![](https://shen89s.github.io/resFiles/r2/缺陷优先级.jpg)

需要我们测试人员铭记的是，修复对测试有阻塞的缺陷优先级应该更高，比修复普通严重缺陷以及开发新功能相比。“测试阻塞”意味着测试并没有完成本版本的功能的严重，被阻塞的部分功能质量是未知的。如果放任不管而继续开发新功能，会大大增加集成时的风险。因此我们通常在提缺陷的时候除了标注严重级别意外，还有标注优先级，严重级别一旦达成一致以后不再改变，而优先级通常会随着缺陷的修复情况随时调整，从而达到指导开发人员修复缺陷的顺序。
注：有的公司和团队在缺陷修改优先级上，把阻塞的缺陷严重级别定义为严重，以达到优先修复的目的，针对这点，建议将缺陷严重级别和修复优先级做一下区分，毕竟测试人员还有很多缺陷分析工作，这会导致缺陷统计和分类等不准确。

## 2.哪些缺陷在本版本中需要解决
是指我们希望在本版本中修复的缺陷。显然本版本中需要解决的缺陷，包含上一小节我们讨论的“本版本中必须解决的缺陷”。换句话说，除了那些在本版本中必须解决的缺陷，我们还需要根据缺陷的严重级别和缺陷的修复情况再选择一些缺陷，在本版本中优先解决。作为测试人员除了不亲自上手修复缺陷以外，应该尽可能的指导开发人员加快缺陷的修复进度，其中指导开发进行正确的修复顺序就是一项很重要的工作。 注：当然如果开发人员的修复能力以不足以解决本版本中必须解决的缺陷，例如团队中的部分资源被借调了等等，那么这项工作也就可以不开展了，但通常一个相对成熟稳定的团队，开发和测试比合理的情况下，这项工作还是常常需要做的。 还有一种解决方案是：当开发人员的修复能力不足以解决本版本中必须解决的缺陷时，说明按照当前的计划测试质量问题得不到有效解决，需要调整测试计划，放慢测试版本构建，梳理“本版本中需要解决的缺陷”，指导和辅助开发人员解决缺陷的顺序，加快缺陷的修复进度。

本版本中需要优先解决的缺陷，一般具备以下因素：    
口  缺陷解决改动越大，越需要尽早解决。   
口  涉及需求、方案、设计的修改，需要尽早解决。   
口  缺陷严重级别为“致命”和“严重”的缺陷，需要尽早解决。   

举个列子，假如我们在某一个build版本中一共发现14个缺陷，情况如下表：   
<table>
	<tr>
		<th>缺陷ID</th>
		<th>是否会阻塞</th>
		<th>严重级别</th>
		<th>修复改动</th>
		<th>缺陷ID</th>
		<th>是否会阻塞</th>
		<th>严重级别</th>
		<th>修复改动</th>
	</tr>
	<tr>
		<td>缺陷1</td>
		<td>是</td>
		<td>一般</td>
		<td>改动一般</td>
		<td>缺陷8</td>
		<td>否</td>
		<td>严重</td>
		<td>改动复杂</td>
	</tr>
	<tr>
		<td>缺陷2</td>
		<td>否</td>
		<td>致命</td>
		<td>改动一般</td>
		<td>缺陷9</td>
		<td>否</td>
		<td>严重</td>
		<td>涉及需求</td>
	</tr>
	<tr>
		<td>缺陷3</td>
		<td>是</td>
		<td>一般</td>
		<td>改动一般</td>
		<td>缺陷10</td>
		<td>否</td>
		<td>一般</td>
		<td>改动一般</td>
	</tr> 
	<tr>
		<td>缺陷4</td>
		<td>是</td>
		<td>严重</td>
		<td>改动复杂</td>
		<td>缺陷11</td>
		<td>否</td>
		<td>一般</td>
		<td>改动复杂</td>
	</tr>
	<tr>
		<td>缺陷5</td>
		<td>否</td>
		<td>致命</td>
		<td>改动一般</td>
		<td>缺陷12</td>
		<td>否</td>
		<td>一般</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷6</td>
		<td>否</td>
		<td>致命</td>
		<td>改动复杂</td>
		<td>缺陷13</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 	
	<tr>
		<td>缺陷7</td>
		<td>否</td>
		<td>严重</td>
		<td>改动一般</td>
		<td>缺陷14</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 	
</table>
我们假设在本版本中，开发人员有能力修复8个缺陷，那么其中缺陷1、缺陷3、缺陷4会造成测试阻塞，为必须解决。剩下的缺陷，我们根据缺陷的严重级别、改动大小情况来排序，分析选取过程我们可以按照如下方式选取：  
口  对测试阻塞必须解决的缺陷-缺陷1、缺陷3、缺陷4   
口  缺陷严重级别非常高，缺陷改动大(复杂/涉及需求)-缺陷6   
口  缺陷严重级别非常高，缺陷改动一般-缺陷2、缺陷5   
口  缺陷严重级别高，缺陷改动大(复杂/涉及需求)-缺陷8、缺陷9   
口  缺陷严重级别高，缺陷改动一般-缺陷7   
口  缺陷严重级一般，缺陷改动大(复杂/涉及需求)-缺陷11、缺陷12   
口  缺陷严重级一般，缺陷改动一般-缺陷10   
口  其他-缺陷13、缺陷14  

按照选取顺序我们又选择了缺陷2、缺陷5、缺陷6、缺陷8、缺陷9，组成了最后我们本版本需要解决的缺陷是：缺陷1、缺陷2、缺陷3、缺陷4、缺陷5、缺陷6、缺陷8、缺陷9。需要注意的时，即使都是本版本中需要解决的缺陷，也需要注意优先级：缺陷1、缺陷3、缺陷4、缺陷6、缺陷2、缺陷5、缺陷8、缺陷9。

## 3.当前缺陷趋势是否正常

[缺陷趋势分析技术](books/缺陷趋势分析.md)能够帮助我们分析缺陷是否收敛，在测试过程中我们通过关注分析累积发现的缺陷趋势图，就可以判断缺陷趋势是否正常。我们在讨论和分析缺陷趋势图时通常是以测试阶段为单位，但实际上，每个测试阶段都会包含一个或者多个版本，一个版本又有可能需要测试若干天。

我们先来回顾一下“拐点”的意义：   
测试策略不变的情况下，出现拐点，说明当前测试已经不能有效的发现系统的缺陷，当前测试可以按照计划结束，进入下一阶段的测试。   
测试策略不变说明测试对象和测试方法没有发生变化，我们可以可以理解为:   
口  测试策略中测试方法不同(同一个测试对象)，就不有应该出现拐点。   
口  测试策略中测试对象不同（同样的测试方法），也不应该出现拐点。   

按照以上原则，我们结合自己产品测试流程，要想知道当前的缺陷趋势是否正常，就必须清楚当前测试策略下完整的测试流程缺陷趋势是怎样的，做到能够预估理想情况下的缺陷趋势图，能够预计符合预期的趋势图中各拐点出现的位置，以及能够分析趋势图上的拐点是否符合我们的策略和预期，结合当前测试所处的阶段和具体测试情况，就能很容易的判断当前的缺陷趋势是否正常。在分析的过程中我们可以结合[缺陷趋势分析技术](books/缺陷趋势分析.md)中的方法，将判定缺陷趋势是否正常简化为“判定拐点的出现是否过早或过晚”，以及按照其中的方法调整测试策略来应对和纠正缺陷趋势。



举个例子，以下是一个简化的gitflow模式下的测试流程：

![](https://shen89s.github.io/resFiles/r2/预估缺陷趋势图.jpg)

口  在Feature测试阶段，一个Feature就相当于一个单独功能模块，所以单个Feature的功能测试后期，由于测试方法和测试对象未发送变化会出现第一个拐点-拐点1   
口  F_build002版本由于测试方法不同，会再次发现大量缺陷，即出现第二个拐点-拐点2。   
口  F_build002版本后期，会像F_build001后期一样出现第三个拐点-拐点3。   
口  在DEV测试阶段,D_build001~D_build002都会有新的Feature功能合入，而随着功能的不断集成，系统也会越来越复杂，测试方法从单功能测试逐步转化为单功能测试+多功能测试，所以D_build001~D_build002不应该出现拐点。   
口  D_build003是一个回归测试版本，此时没有新Feature合入，测试方法和D_build001~D_build002相比也没有发生变化，所以在此阶段会出现一个拐点-拐点4。   
口  在Release测试阶段，R_build001虽然也是功能回归测试，但集成测试和系统测试是有区别的，R_build001和D_build003相比，系统的复杂度、硬件外设等都会有很多的区别，所以进入Release测试以后很快会出现另外一个拐点-拐点5。   
口  R_build002和R_build001相比测试方法不同，所以会出现拐点-拐点6。   
口  R_build003是探索式测试和R_build002相比测试方法不同，所以他们之间会有一个拐点-拐点7。   
口  最后一个拐点应该在R_build003后期出现比较合适。


## 4.当前缺陷修复是否引入了新缺陷？

当我们进过分析和定位已发现的缺陷后，如果发现有缺陷是因为缺陷修复而引入的，这说明当前缺陷修复质量不高，对于测试人员来说，可以采取以下措施：   
口  验证缺陷时，除了验证缺陷本身是否被正确的修复了，还需要围绕缺陷展开探索式测试。   
口  增加或者加强开发人员和测试人员对修改内容、影响范围等的沟通，尤其针对重点修改或者较大改动的缺陷。   
口  可以和开发人员约定一些有利于缺陷修改质量的措施，如对缺陷的代码进行review后才能合入，每修改的缺陷开发人员都需要提供自检报告单等等。      
口  增大对基本功能进行回归测试的比例。   

缺陷修改引入缺陷还会带来另外一个影响，就是缺陷趋势不会收敛。我们可以通过控制提高缺陷修复质量，来促进缺陷的快速收敛，也可以通过缺陷不收敛而方向印证是否存在大量的修改缺陷引入了新缺陷。


* * *
:bell: A20180715-一个优秀团队里的成员，不会只顾自己的工作，而把未知和压力抛到后期或队友，正确的协作才是一个团队的灵魂。 
 

