# 每日缺陷跟踪

对于所有的测试人员，“缺陷”是测试的重要产出，每天跟踪缺陷列表非常重要，我们需要实时重点关注测试中的这几个问题：

口  哪些缺陷在本版本中必须解决？

口  哪些缺陷在本版本中需要解决？

口  缺陷的趋势是否正常？

口  是否存在修改缺陷而引入了新缺陷？

![](https://shen89s.github.io/resFiles/每日缺陷跟踪需要关注的问题.jpg)

这几个问题都会影响后续测试的执行，测试架构师在必要的时刻可能也需要由此来调整测试策略。

## 1.哪些缺陷必须在本版本中解决

在版本测试过程中，判定该问题的标准只有一个，那就是“会不会对后续测试造成阻塞”。   
需要注意的是不要和“缺陷的严重级别”混淆。缺陷的严重级别是指缺陷如果不修复，会对用户造成的影响。我们通常认为缺陷的严重程度越高，修复它的优先级就应该越高，这一点没问题，但是严重或致命的缺陷，却不一定会让测试用例执行发生“阻塞”。   

例如，我们在做ABC系统模块的集成功能测试，如图我们会有4条测试用例，假设我们已知B模块存在bug1和bug2，那么执行测试用例时，所有经过bug所在方块的用例执行结果都会是失败，如图所示用例1、用例3、用例4的执行结果都会失败。用例1的测试没有执行到代码C中，用例3的测试没有执行到代码A中，这时我们可以称用例1和用例3被bug1阻塞了，和测试用例4执行结果为失败不同的是，用例1和用3执行存在阻塞，这种阻塞体现了一种未知性：我们并不知道这些用例最后的执行结果是什么，意味着测试内容并没有顺利的执行完。   

我们在来分析一下bug1和bug2，假设对于用户来说，bug1的严重程度是一般，bug2的严重程度为严重，此时资源只允许我们修复1个缺陷，我们应该优先修复那个缺陷呢？我们应该优先修复bug1，这是因为bug2只有到了产品发布阶段才会造成严重的用户影响，而bug1如果不修复，那么下个版本用例1和用例3还是不能执行，对于测试来说本版本测试内容依然还没完成。   
![](https://shen89s.github.io/resFiles/r2/缺陷优先级.jpg)

需要我们测试人员铭记的是，修复对测试有阻塞的缺陷优先级应该更高，比修复普通严重缺陷以及开发新功能相比。“测试阻塞”意味着测试并没有完成本版本的功能的严重，被阻塞的部分功能质量是未知的。如果放任不管而继续开发新功能，会大大增加集成时的风险。因此我们通常在提缺陷的时候除了标注严重级别意外，还有标注优先级，严重级别一旦达成一致以后不再改变，而优先级通常会随着缺陷的修复情况随时调整，以指导开发人员修复缺陷的顺序。

## 2.哪些缺陷在本版本中需要解决

是指我们希望在本版本中修复的缺陷。显然本版本中需要解决的缺陷，包含上一小节我们讨论的“本版本中必须解决的缺陷”。换句话说，除了那些在本版本中必须解决的缺陷，我们还需要根据缺陷的严重级别和缺陷的修复情况再选择一些缺陷，在本版本中优先解决。作为测试人员除了不亲自上手修复缺陷以外，应该尽可能的指导开发人员加快缺陷的修复进度，其中指导开发进行正确的修复顺序就是一项很重要的工作。   

本版本中需要优先解决的缺陷因素：   

口  缺陷修复改动越大，越需要尽早修复。

口  涉及需求、方案、设计的修改，需要尽早修复。

口  缺陷严重级别为“致命”和“严重”的缺陷，需要尽早修复。   

例如，我们在某一个build版本中一共发现15个缺陷，情况如下表：
<table>
	<tr>
		<th>缺陷</th>
		<th>是否会测试阻塞</th>
		<th>缺陷严重级别</th>
		<th>缺陷修复改动</th>
	</tr>
	<tr>
		<td>缺陷1</td>
		<td>是</td>
		<td>一般</td>
		<td>改动一般</td>
	</tr>
	<tr>
		<td>缺陷2</td>
		<td>否</td>
		<td>致命</td>
		<td>改动一般</td>
	</tr>
	<tr>
		<td>缺陷3</td>
		<td>是</td>
		<td>一般</td>
		<td>改动一般</td>
	</tr> 
	<tr>
		<td>缺陷4</td>
		<td>是</td>
		<td>严重</td>
		<td>改动复杂</td>
	</tr>
	<tr>
		<td>缺陷5</td>
		<td>否</td>
		<td>致命</td>
		<td>改动一般</td>
	</tr> 	
	<tr>
		<td>缺陷6</td>
		<td>否</td>
		<td>致命</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷7</td>
		<td>否</td>
		<td>严重</td>
		<td>改动一般</td>
	</tr> 	
	<tr>
		<td>缺陷8</td>
		<td>否</td>
		<td>严重</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷9</td>
		<td>否</td>
		<td>严重</td>
		<td>涉及需求</td>
	</tr> 	
	<tr>
		<td>缺陷10</td>
		<td>否</td>
		<td>一般</td>
		<td>改动一般</td>
	</tr> 	
	<tr>
		<td>缺陷11</td>
		<td>否</td>
		<td>一般</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷12</td>
		<td>否</td>
		<td>一般</td>
		<td>改动复杂</td>
	</tr> 	
	<tr>
		<td>缺陷13</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 
	<tr>
		<td>缺陷14</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 
	<tr>
		<td>缺陷15</td>
		<td>否</td>
		<td>提示</td>
		<td>改动一般</td>
	</tr> 
</table>

我们假设在本版本中，开发人员有能力修复8个缺陷，那么其中缺陷1、缺陷3、缺陷4会造成测试阻塞，为必须解决。剩下的缺陷，我们根据缺陷的严重级别、改动大小情况来排序，分析选取过程我们可以按照如下方式选取：   

口  对测试阻塞必须解决的缺陷-缺陷1、缺陷3、缺陷4

口  缺陷严重级别非常高，缺陷改动大(复杂/涉及需求)-缺陷6

口  缺陷严重级别非常高，缺陷改动一般-缺陷2、缺陷5

口  缺陷严重级别高，缺陷改动大(复杂/涉及需求)-缺陷8、缺陷9

口  缺陷严重级别高，缺陷改动一般-缺陷7

口  缺陷严重级一般，缺陷改动大(复杂/涉及需求)-缺陷11、缺陷12

口  缺陷严重级一般，缺陷改动一般-缺陷10

口  其他-缺陷13、缺陷14、缺陷15

按照选取顺序我们又选择了缺陷2、缺陷5、缺陷6、缺陷8、缺陷9，组成了最后我们本版本需要解决的缺陷是：缺陷1、缺陷2、缺陷3、缺陷4、缺陷5、缺陷6、缺陷8、缺陷9。需要注意的时，即使都是本版本中需要解决的缺陷，也需要注意优先级：缺陷1、缺陷3、缺陷4、缺陷6、缺陷2、缺陷5、缺陷8、缺陷9。

## 3.缺陷趋势是否正常

[缺陷趋势分析技术](books/缺陷趋势分析.md)能够帮助我们分析缺陷是否收敛，在测试过程中我们通过关注分析累积发现的缺陷趋势图，就可以判断缺陷趋势是否正常。

### 3-1预计拐点会在那个版本出现（按照公司流程重写）

我们在讨论和分析缺陷趋势图时通常是以测试阶段为单位，但实际上，每个测试阶段都会包含一个或者多个版本，在版本测试时，预计在哪个版本会出现拐点，才比较符合我们的策略和预期，是我们分析的一个问题。   
我们先来回顾一下“拐点”的意义：测试策略不变的情况下，出现拐点，说明当前测试已经不能有效的发现系统的缺陷，当前测试可以按照计划结束，进入下一阶段的测试。   
测试策略不变，说明测试对象和测试方法没有发生变化，我们可以可以理解为：   
口  测试策略中测试方法不同，就不有应该出现拐点。   
口  测试方法不变，但测试对象不同，也不应该出现拐点。  
按照以上原则，我们对各个测试阶段以及每个测试阶段中的各个测试版本预估缺陷趋势图。   
![](https://shen89s.github.io/resFiles/r2/预估缺陷趋势图.jpg)
口  在集成测试阶段，build1~build4都会有新功能合入，且随着功能不断的集成，系统会越来越复杂和完整，测试方法也会从单功能测试，逐步转变为单功能测试+多功能测试，所以在build1~build4阶段不应该有拐点的出现。   
口  build5是一个回归测试版本，此时没有新功能合入，测试方法和build1-4相比，也没有发生变化，所以集成测试阶段的拐点应该在build5版本出现比较合适。   
口  在系统测试阶段，ST1虽然也是功能测试，被测试对象也没有发生变化，但在测试执行顺序、功能测试的复杂度上都会与集成测试有所不同，所以进入系统测试阶段应该会比较快的出现另个一个拐点。   
口  ST2的测试方法和ST1的测试方法不同，不应该出现拐点。
口  ST3和ST4都是探索性测试和回归测试，下一个拐点应该出现的ST3后期或者ST4初期比较合适。
口  进入验收测试阶段后，由于AT1的测试方法发生了变化，应该会出现一个新的拐点，但这种缺陷上升趋势不应该持续太久，毕竟我们已经经过大量的测试，在AT1后期或AT2前期就应该出现拐点。

### 3-2判定当前版本的缺陷趋势是否正常（按照公司流程重写）

当我们对缺陷趋势已经做到了心中有数，判定当前版本的缺陷趋势是否正常就变得简单了，我们可以简化为“判定拐点的出现是否过早或过晚”。



## 4.是否存在修改缺陷而引入了新缺陷

当我们分析定位本版本缺陷，发现很多因为修改缺陷而引入了新缺陷或缺陷未有效解决，这说明当前版本开发修改缺陷的质量不高，对于测试人员来说，可以采取以下措施：
- 验证缺陷时，除了验证缺陷本身是否被正确的修复了，还需要围绕缺陷展开探索式测试。
- 增大对基本功能进行回顾测试的比例。
- 增加或者加强开发人员和测试人员对修改内容、影响范围等的沟通，尤其针对重点修改或者较大改动的缺陷。
- 可以和开发人员约定一些有利于缺陷修改质量的措施，如对缺陷的代码进行review后才能合入，每修改的缺陷开发人员都需要提供自检报告单等等
缺陷修改引入缺陷还会带来另外一个影响，就是缺陷不会收敛。我们可以通过控制提高缺陷修复质量，来促进缺陷的快速收敛。

